//! Deterministic simulation of DMLS execution.
//!
//! This example simulates a distributed MLS (DMLS) environment with multiple participants.
//! It initializes a group of participants, processes updates, and handles message broadcasting and delivery.
//! It uses a random number generator to determine the order of events, simulating an asynchronous network where messages are sent and received in a non-deterministic manner such that timing of message delivery cannot be predicted.
//! Events are uniformly selected from a queue, and each event is processed in a loop until all events are handled.
//! The simulation tracks the number of messages sent and received, as well as the total bytes sent and received.

use distributed_mls::{DistributedMlsAgent, DistributedMlsError, MlsMessageQueue};
use mls_rs::MlsMessage;
use mls_rs_codec::MlsSize;
use rand_chacha::rand_core::{RngCore, SeedableRng};

use mls_rs_crypto_openssl as _;

enum Event {
    Initialize(u16),
    Update(u16),
    Broadcast(u16, MlsMessage),
    Deliver(u16, MlsMessage, u16),
    Process(MlsMessage, u16),
}

/// struct for command-line arguments
#[derive(clap::Parser, Debug)]
struct CliArgStruct {
    /// number of participants
    #[arg(short, long, default_value_t = 3)]
    num_participants: u16,
    /// seed for rng
    #[arg(long, default_value_t = 0)]
    seed: u64,
}

fn handle_event(
    event: Event,
    agents: &mut Vec<DistributedMlsAgent>,
    queues: &mut Vec<MlsMessageQueue>,
    events: &mut Vec<Event>,
    messages_sent: &mut usize,
    messages_received: &mut usize,
    bytes_sent: &mut usize,
    bytes_received: &mut usize,
    event_counter: &mut usize,
    process_counter: &mut usize,
) {
    match event {
        Event::Update(i) => {
            // update participant i
            let commit = agents[i as usize].update().unwrap();
            // broadcast commit
            events.push(Event::Broadcast(i, commit));
            // log
            println!("{event_counter}:Update({i}):{messages_sent}:{messages_received}:{bytes_sent}:{bytes_received}:{process_counter}");
        }
        Event::Initialize(i) => {
            // initialize group; pull key packages as necessary
            let mut key_packages = Vec::new();
            for j in 0..agents.len() as u16 {
                if j != i {
                    key_packages.push(agents[j as usize].generate_key_package_message().unwrap());
                }
            }
            let welcomes = agents[i as usize].initialize(key_packages).unwrap();
            // broadcast welcome messages
            for welcome in welcomes {
                events.push(Event::Broadcast(i, welcome));
            }
            // log
            println!("{event_counter}:Initialize({i}):{messages_sent}:{messages_received}:{bytes_sent}:{bytes_received}:{process_counter}");
        }
        Event::Broadcast(i, message) => {
            // broadcast message to all participants
            for j in 0..agents.len() as u16 {
                if j != i {
                    events.push(Event::Deliver(i, message.clone(), j));
                }
            }
            // log
            *messages_sent += 1;
            *bytes_sent += message.mls_encoded_len();
            println!("{event_counter}:Broadcast({i},{:x}):{messages_sent}:{messages_received}:{bytes_sent}:{bytes_received}:{process_counter}", md5::compute(&message.to_bytes().unwrap()));
        }
        Event::Deliver(i, message, j) => {
            // enqueue message for participant j
            queues[j as usize].enqueue(message.clone());
            events.push(Event::Process(queues[j as usize].dequeue().unwrap(), j));
            // log
            *messages_received += 1;
            *bytes_received += message.mls_encoded_len();
            println!("{event_counter}:Deliver({i},{:x},{j}):{messages_sent}:{messages_received}:{bytes_sent}:{bytes_received}:{process_counter}", md5::compute(&message.to_bytes().unwrap()));
        }
        Event::Process(message_in, j) => {
            // process message for participant j
            match agents[j as usize].process(message_in.clone()) {
                Ok((messages_out, _)) => {
                    // broadcast any messages generated by processing
                    for message_out in messages_out {
                        events.push(Event::Broadcast(j, message_out));
                    }
                }
                Err(DistributedMlsError::MessageDeferred(message_out)) => {
                    events.push(Event::Process(message_out, j));
                }
                Err(e) => panic!("{e:?}"),
            }
            // log
            *process_counter += 1;
            println!("{event_counter}:Process({:x},{j}):{messages_sent}:{messages_received}:{bytes_sent}:{bytes_received}:{process_counter}", md5::compute(&message_in.to_bytes().unwrap()));
        }
    }
    *event_counter += 1;
}

fn main() {
    // parse cli args
    let args: CliArgStruct = clap::Parser::parse();
    // rng
    let mut rng = rand_chacha::ChaCha20Rng::seed_from_u64(args.seed);
    // event queue
    let mut events = Vec::new();
    // participants
    let mut queues = Vec::new();
    let mut agents = Vec::new();
    // counters
    let mut messages_sent = 0;
    let mut messages_received = 0;
    let mut bytes_sent = 0;
    let mut bytes_received = 0;
    let mut event_counter = 0;
    let mut process_counter = 0;
    // create participants & seed initialization events
    for i in 0..args.num_participants {
        agents.push(DistributedMlsAgent::new(i.to_be_bytes().to_vec()).unwrap());
        queues.push(MlsMessageQueue::new());
        events.push(Event::Initialize(i));
    }
    // loop for initialization
    while !events.is_empty() {
        handle_event(
            events.remove(rng.next_u64() as usize % events.len()),
            &mut agents,
            &mut queues,
            &mut events,
            &mut messages_sent,
            &mut messages_received,
            &mut bytes_sent,
            &mut bytes_received,
            &mut event_counter,
            &mut process_counter,
        );
    }
    // seed update events
    for i in 0..args.num_participants {
        events.push(Event::Update(i));
    }
    // loop for updates
    while !events.is_empty() {
        handle_event(
            events.remove(rng.next_u64() as usize % events.len()),
            &mut agents,
            &mut queues,
            &mut events,
            &mut messages_sent,
            &mut messages_received,
            &mut bytes_sent,
            &mut bytes_received,
            &mut event_counter,
            &mut process_counter,
        );
    }
}
